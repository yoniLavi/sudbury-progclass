<!DOCTYPE html>
<html>
  <head>
    <meta name="generator"
    content="HTML Tidy for HTML5 (experimental) for Windows https://github.com/w3c/tidy-html5/tree/c63cc39" />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <title>Lesson 7 - Hello Web</title>
    <link rel="stylesheet" href="static/css/main.css" />
    <link rel="stylesheet" href="static/css/lesson.css" />

    <link rel="stylesheet" href="static/highlightjs/styles/default.css">
    <script src="static/highlightjs/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <header>
      <div class="level">7</div>
      <div class="title">היכרות ראשונה עם הווב</div>
    </header>
    <section class="level1 activity">
      <h1>שלב 33: מבוא - מהו הווב?</h1>
      כמו שסיפרתי בשיעור הקודם, הווב הוא דרך (שבליבה פרוטוקול http) להעביר מסמכים (בעיקר דפי html) דרך רשת האינטרנט.
      בווב יש שני סוגי משתתפים - שרת ודפדפן.
      <ol>
        <li>
          דפדפן (נקרא גם לקוח) - תוכנה שאנחנו הגולשים משתמשים בה כדי לבקש מסמכים.
        </li>
        <li>
          שרת (נקרא גם אפליקציית ווב)- תוכנת מחשב (שלרוב יושבת במחשב אחר שגם הוא נקרא שרת) שאחראיות לספק ללקוחות את דפי הווב שהם מבקשים
        </li>
        <li>
          הדרך שבה דפדפן מבקש מסמך משרת היא ע"י <span dir="ltr">URL (Uniform Resource Locator)</span>.
          ה-URL היא כתובת שאומרת איזה מסמך הדפדפן רוצה לקבל והיא בנויה משני חלקים עיקריים:
          כתובת השרת, למשל - <code>en.wikipedia.org</code>
          וכתובת המסמך, למשל - <code>/wiki/Sudbury_school</code>
          <br>
          אז אם נבקש בעזרת הדפדפן את ה-URL הזה
          <a href="http://en.wikipedia.org/wiki/Sudbury_school">http://en.wikipedia.org/wiki/Sudbury_school</a>,
          נקבל מהשרת של וויקיפדיה את הדף על בתי הספר של מודל סאדברי.
        </li>
      </ol>
    </section>
    <section class="level1 activity">
      <h1>שלב 34: פונקציות שמחזירות דברים</h1>
      <ol>
        <li>
          עד עכשיו, יצרנו רק פונקציות שעושות פעולות.
          אבל בעצם רוב הפונקציות המעניינות לא עושות שום דבר בעצמן, אלא רק מחשבות דברים.
        </li>
        <li>
          פונקציות אלו משתמשות בפקודה <code>return</code>.
          הפקודה הזאת מפסיקה את ריצת הפונקציה ומחזירה את הערך ששמים בה.
          למשל תנסו להריץ את זה:
          <pre class="sourceCode python"><code>def doubler(num):
    return num * 2
    print("No one will ever reach this")

x = 21
double_x = doubler(x)
print(double_x)
</code></pre>
        </li>
        <li>
          שימו לב שבעבר נעזרנו כבר בפונקציות שמחזירות ערכים בעזרת <code>return</code> וביניהן:
          <code>input</code>, <code>choice</code> ו-<code>randrange</code>
        </li>
        <li>
          הנה שימוש לא מוצלח ב-<code>return</code>, תריצו את התוכנה הבאה, תבינו למה היא לא עובדת ותנסו לתקן אותה:
          <pre class="sourceCode python"><code>def foo(num):

hmm()?
</code></pre>
        </li>
      </ol>
    </section>
    <section class="level1 activity">
      <h1>שלב 35: נתקין את פלאסק</h1>
      בשלב הבא נתחיל לבנות שרת ווב, אבל לפני זה צריך להכין את הכלי שאיתו נעבוד.
      <ol>
        <li>
          אנחנו לא נבנה את השרת מאפס אלא נשתמש בספרייה שנקראת פלאסק (<code>flask</code>).
          פלאסק היה ספרייה מסוג שנקרא פריימוורק (Web Framework).
          המטרה של פריימורק היא לספק למתכנת את כל הכלים שקשור לתקשורת עם הלקוחות,
          כך שלמתכנת נשאר רק לבנות את התוכן שיוחזר עבור כל URL.
        </li>
        <li>
          פייתון מגיע כבר "מהקופסא" עם הרבה ספריות כמו turtle ו-random,
          אבל יש המון ספריות נוספות ומעולות שאפשר להוריד מהאינטרנט.
          הדרך הכי נוחה בפייתון להתקין ספריות היא כלי קטן שנקרא פיפ (<code>pip</code>).
          תנסו לכתוב ב-bash <code>pip</code> כדי לראות עם אולי פיפ כבר מותקן אצלכם, ואם כן, אתם יכולים לדלג לסעיף הבא.
          אם אין לכם את פיפ, תורידו את הקובץ הבא <a href="https://bootstrap.pypa.io/get-pip.py">get-pip</a> ואז תתקינו אותו בעזרת הפקודה הבאה ב-bash (בתיקיה שאליה הורדתם את הקובץ):
          <pre class="sourceCode bash"><code>python get-pip.py
</code></pre>
        </li>
        <li>
          ועכשיו שיש לכם את פיפ, אתם יכולים להתקין את פלאסק בעזרת הפקודה הבאה ב-bash
          <pre class="sourceCode bash"><code>pip install flask
</code></pre>
        </li>
      </ol>
    </section>
    <section class="level1 activity">
      <h1>שלב 36: תוכנה ראשונה בפלאסק</h1>
      עכשיו אנחנו מוכנים להתחיל לבנות שרת ווב פשוט וכך להכיר את פלאסק.
      <ol>

        <li>
          שרתי ווב הם דומים קצת לתוכנות שורת הפקודה שהכנו בשיעור 4,
          אבל הבדל עיקרי הוא שאנחנו לא צריכים לעשות לולאה כמו שעשינו אז,
          אלא פלאסק דואג בשבילנו לכל זה, ואנחנו רק צריכים לכתוב את הפעולות אשר יקרו עבור כל URL.
        </li>
        <li>
          ככה נראה שרת פשוט בפלאסק שאומר שלום לעולם:
          <pre class="sourceCode python"><code>import flask

app = flask.Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World!'

app.run(debug=True)
</code></pre>
          תריצו את הקוד הזה ותיכנו בדפדפן ל- <a href="http://127.0.0.1:5000">http://127.0.0.1:5000/</a> (הכתובת 127.0.0.1 זאת תמיד הכתובת של המחשב המקומי שלכם ו-5000 זה הפורט שפלאסק מעדיף).
          שימו לב שפלאסק יריץ את השרת בלולרה אינסופית עד שתהרגו את התוכנה בעזרת Ctrl+C.
        </li>
        <li>
          בואו ננסה להבין מה מכיל הקוד שכתבנו.
          השורה <code>app = flask.Flask(__name__)</code> מגדירה אפליקציית פלאסק חדשה, כאשר המשתמה המיוחד <code>__name__</code> מכיל את שם הקובץ שאנחנו בתוכו.
          עכשיו יש לנו במשתנה <code>app</code> את כל מה שאנחנו צריכים בשביל לעבוד על פלאסק.
          <br>
          דבר אחר שלא ראינו עד כה הוא השורה שמתחילה בשטרודל - <code>@app.route('/')</code>.
          השורה הזאת נקראת דקורטור (כי היא מקשטמ פונקציה) והיא דרך שבא אנחנו אומרים לפלאסק מה לעשות עם הפונקציה מתחת.
          במקרה הזה, אנחנו אומרים לפלאסק שהפונקציה הזאת אחראית לשרת את ה-URL <code>/</code> (שורש האתר).
          <br>
          השורה האחרונה <code>app.run(debug=True)</code> אחראית פשוט להריץ את השרת.
        </li>
      </ol>
    </section>
    <section class="level1 activity">
      <h1>שלב 37: בואו נכין עוד עמודים</h1>
      עכשיו שהבנו את העיקרון, בואו נראה מה עוד אפשר לעשות.
      <ol>
        <li>
          בואו נוסיף עוד עמוד.
          תשנו את הקוד כך שיכיל את הפונקציה החדשה ותשמרו:
          <pre class="sourceCode python"><code>import flask

app = flask.Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World!'

@app.route('/hello')
def hello():
    return "Hello Yoni"

app.run(debug=True)
</code></pre>
          שימו לב שהפעם שמנו בדוקרטור את ה-URL <code>/hello</code>,
          אז עכשיו אתפ יכולים לגלוש בדפדפן לכתובת <a href="http://127.0.0.1:5000/hello">http://127.0.0.1:5000/hello</a> ותראו את העמוד החדש.
          <br>
          אגב, שימו לב שלא היה צורך לעצור את התוכנה ולהריץ אותה מחדש,
          הסיבה לכך היא שכתבנו בשורה האחרונה <code>debug=True</code>
          וכך קיבלנו מפלאסק כל מיני אפשרויות שעוזרות לנו בפיתוח.
          <br>
          חוץ מזה, עם עדיין לא שיניתם את השם בקוד בשביל שיגיד שלום לכם ולא לי, למה אתם מחכים?
        </li>
        <li>
          רגע, למה בעצם שהשרת שלנו יגיד שלום רק למישהו אחד, בואו נעשה שהוא יוכל להגיד שלום לכל אחד.
          בשביל זה, אנחנו יכולים להגיד לדקורטורים של פלאסק שיקבלו פרמטרים,
          אז בואו נשנה את הפונקציה והדקורטור:
          <pre class="sourceCode python"><code>import flask

app = flask.Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World!'

@app.route('/hello/<name>')
def hello(name):
    return "Hello there %s" % name

app.run(debug=True)
</code></pre>
          שינינו את הדקורטור כך שיקבל את כל הכתובות מהצורה <code>/hello/<name></code>,
          כלומר שיכול להופיע אחרי hello כל שם.
          אז בואו תנסו לגלוש ל-<a href="http://127.0.0.1:5000/hello/Yoni">http://127.0.0.1:5000/hello/Yoni</a>.
          מה שקרה פה זה שהפרמטר <code>name</code> נכנס מה-URL לפונקציה שלנו ואז להודעה שמוחזרת לדפדפן.
          תנסו להגיד שלום לעוד שמות.
          <br>
          שימו גם לב, שב-URLים יש הבדל בין אותיות קטנות לגדולות, אז השרת יודע להבדיל למשל בין <a href="http://127.0.0.1:5000/hello/Yoni">http://127.0.0.1:5000/hello/Yoni</a>
          לבין <a href="http://127.0.0.1:5000/hello/yoni">http://127.0.0.1:5000/hello/yoni</a>
        </li>
      </ol>
    </section>
    <section class="level1 activity">
      <h1>שלב 38: פלאסק והווב</h1>
      רגע, בשיעור שעבר דיברנו על הווב, אבל בינתיים זה סתם נראה כמו עוד תוכנה בפייתון.
      איפה נכנס ה-html?
      <ol>
        <li>
          אז ככה, הדפדפן באמת מצפה שתתנו לו קוד html.
          אם אתם מחזירים סתם טקסט, אז הדפדפן פשוט מתייחס לזה כ-html לא מעוצב.
          בשיעור הבא, נלמד על דרך חכמה לארגן html בשרת שלנו,
          אבל בינתיים בואו פשוט נשנה את הפונקציות שלנו כדי שיחזירו קטעי html ויעצבו את השם שלנו:
          <pre class="sourceCode python"><code>import flask

app = flask.Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World!'

@app.route('/hello/<name>')
def hello(name):
    return "Hello there <b>%s</b>" % name

@app.route('/bye/<name>')
def bye(name):
    return "Goodbye <i>%s</i>" % name

app.run(debug=True)
</code></pre>
          אולי אתם יכולים לעשות עמודים יותר יפים? תנסו לשחק עם ה-html ולעשות משהו מגניב.
          למשל, אולי אתם יכולים להוסיף תמונות לעמוד?
        </li>
        <li>
          אוקי, אז אפשר להשתמש ב-html,
          אבל אולי זה נראה לכם שבינתיים לא עשינו שום דבר מעניין ולמה בכלל אנחנו צריכים את פייתון בשביל השטויות האלו.
          אם זה מה שאתם חושבים, אז, קודם כל, אתם צודקים.
          <br>
          מה שכן, זה שאנחנו יכולים להכניס כל לוגיקה שאנחנו רוצים בתוך קוד הפייתון שלנו בשביל לקבל החלטות לגבי מה להחזיר לדפדפן.
          למשל, בואו ניקח את פונקציית המספרים הגדולים משיעור 5:
          <pre class="sourceCode python"><code>import flask

app = flask.Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World!'

@app.route('/hello/<name>')
def hello(name):
    return "Hello there <b>%s</b>" % name

@app.route('/bye/<name>')
def bye(name):
    return "Goodbye <i>%s</i>" % name

@app.route('/number/<number_name>')
def large_number(number_name):
  number = int(number_name)

  if number > 100000:
    return "Thank you, %s is good enough for me" % number
  else:
    return "Are you kidding me?! That's way too small"

app.run(debug=True)
</code></pre>
          ככה אנחנו יכולים לקבל בשרת החלטות בהתאם לקלט מהמשתמש
          להחזיר לו את מה שאנחנו מחליטים שהוא אמור לראות.
          <br>
          תנסו אולי לכתוב עוד פונקציה שמקבלת החלטות.
          למשל, תנסו לכתוב פונקציה שמחכה לסיסמא
          ומספרת לכם סוד רק אם אתם יודעים את התשובה הנכונה.
        </li>
        <li>
          יצא לכם עד עכשיו להקליד בדפדפן כתובת שהשרת לא מכיר ולקבל שגיאה?
          למשל, האם ניסיתם לבקר ב-<a href="http://127.0.0.1:5000/nosuchpage">http://127.0.0.1:5000/nosuchpage</a>?
          <br>
          אם כן, זה אומר שקיבלתם את עמוד 404 של פלאסק שסיפר לכם שאין כזאת כתובת.
          אבל זה לא עמוד מוצלח במיוחד.
          בואו נשנה את עמוד השגיאה על זה למשהו יותר אינפורמטיבי:
          <pre class="sourceCode python"><code>import flask

app = flask.Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World!'

@app.route('/hello/<name>')
def hello(name):
    return "Hello there <b>%s</b>" % name

@app.route('/bye/<name>')
def bye(name):
    return "Goodbye <i>%s</i>" % name

@app.errorhandler(404)
def page_not_found(error):
    return "404: You're funny, there's no such page", 404

if __name__ == "__main__":
    app.run(debug=True)
</code></pre>
          תנסו לבקר שוב ב-<a href="http://127.0.0.1:5000/nosuchpage">http://127.0.0.1:5000/nosuchpage</a> ותראו את השגיעה החדשה.
          <br>
          אם אםת שואלים את עצמכם מה הקטע עם המספר הזה, אז ככה:
          השרת תמיד צריך להחזיר על כל בקשה לא רק טקסט אלא גם סטטוס מספרי.
          הסטטוס הזה אומר לדפדפן (ולגולשים) האם הכל בסדר, או שאולי כדאי לעשות משהו מיוחד.
          אם לא אומרים לשרת שום דבר, אז הוא מחזיר סטטוס 200 שאומר "הצלחה",
          אבל יש גם הרבה סטטוסים שמספרים על שגיאות מעניינות.
          סטטוס 404 שראינו, למשל, מספר על כך שאין שום דבר בכתובת הזאת.
          <br>
          ויש עוד המון סטטוסים אחרים.
          קבלו <a href="https://www.flickr.com/photos/girliemac/sets/72157628409467125">פירוט של כל הסטטוסים האפשריים בעזרת חתולים</a>
        </li>
      </ol>
    </section>
    <section class="level1 activity">
      <h1>שלב 39: heroku</h1>
      בנינו שרת ווב, אבל בינתיים הוא נגיש רק מהמחשב שלנו,
      והרי אמרתי שאנחנו הולכים לבנות שרת באינטרנט.
      איך נעשה שאפשר יהיה לגשת לשרת שלנו מכל מחשב בעולם?
      <br>
      בעיקרון, אנחנו צריכים לשים את התוכנה שלנו על מחשב שתמיד דלוק ושיש לו כתובת חיצונית (ולא רק ברשת הפנימית של ביה"ס).
      אנחנו יכולים לשלם על מחשב שלם, אבל מצד שני, אנחנו יכולים גם להיעזר בשירות חינמי.
      <br>
      אז כאן משתלב לנו שירות נחמד מאוד שנקרא הרוקו (heroku).
      הרוקו ייתן לנו מקום בחמשבים שלהם לשים בו את הקוד שלנו ככה שיהיה זמין לכולם באינטרנט.
      אם נרצה להרים אתר גדול שיקבל מיליוני משתמשים, נצטרך לשלם להרוקו,
      אבל כל עוד שהשרת שלנו קטן יחסית, הם ייתנו לנו לעבוד בחינם.
      <ol>
        <li>
          בואו נתחיל, תפתחו חשבון בהרוקו <a href="https://id.heroku.com/signup">כאן</a> ואז תתקינו את הכלים שלו מכאן:
          <a href="https://toolbelt.heroku.com/windows">Set up heroku on windows</a>

        </li>
        <li>
          <a href="https://devcenter.heroku.com/articles/getting-started-with-python">heroku</a>
        </li>
      </ol>
    </section>
    <p>הערה: <a href="http://flask.pocoo.org/">אם אתם מעדיפים לרוץ קצת קדימה בעצמכם, כאן תוכלו למצוא את הדוקומנטציה המלאה של ספריית פלאסק</a></p>
  </body>
</html>

